<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i C·ªù Vua - Modern Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #ffffff 0%, #e8f5e9 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            flex-direction: column;
            padding-top: 20px;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.6s ease-out;
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            background: linear-gradient(135deg, #2e7d32 0%, #66bb6a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin: 0 0 30px 0;
            font-size: 3em;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .info-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .player-info {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.3);
            min-width: 200px;
            text-align: center;
        }

        .selected-info {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #333;
            padding: 12px 20px;
            border-radius: 12px;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(252, 182, 159, 0.3);
            flex: 1;
            min-width: 250px;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, minmax(40px, 80px));
            grid-template-rows: repeat(8, minmax(40px, 80px));
            background: linear-gradient(135deg, #2d3436 0%, #636e72 100%);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.2);
            margin: 30px auto;
            width: fit-content;
        }

        .square {
            width: 100%;
            height: 100%;
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            font-size: clamp(24px, 6vw, 50px);
            transition: all 0.2s ease;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .square:hover { transform: scale(0.98); filter: brightness(1.1); }
        .square.light { background: linear-gradient(135deg, #f5deb3 0%, #ffe4b5 100%); box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.5); }
        .square.dark { background: linear-gradient(135deg, #8b7355 0%, #a0826d 100%); box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2); }
        .square.selected { background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%) !important; animation: pulse 0.6s infinite; }
        .square.valid-move { background: radial-gradient(circle, rgba(34, 193, 30, 0.5) 0%, rgba(34, 193, 30, 0.1) 100%) !important; border: 2px solid #22c11e; }
        .square.marked { background: var(--mark-color, rgba(156, 39, 176, 0.3)) !important; box-shadow: inset 0 0 10px var(--mark-color, rgba(156, 39, 176, 0.5)) !important; }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 20px rgba(255, 216, 155, 0.6), inset 0 0 10px rgba(0, 0, 0, 0.3); } 50% { box-shadow: 0 0 30px rgba(255, 216, 155, 0.9), inset 0 0 15px rgba(0, 0, 0, 0.5); } }

        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 30px; flex-wrap: wrap; }
        button { background: linear-gradient(135deg, #2e7d32 0%, #66bb6a 100%); color: white; border: none; padding: 15px 30px; border-radius: 12px; cursor: pointer; font-size: 1.05em; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 5px 15px rgba(46, 125, 50, 0.4); text-transform: uppercase; letter-spacing: 1px; }
        button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(46, 125, 50, 0.6); background: linear-gradient(135deg, #66bb6a 0%, #2e7d32 100%); }
        button:active { transform: translateY(-1px); box-shadow: 0 3px 10px rgba(46, 125, 50, 0.4); }

        .import-section { text-align: center; margin: 30px 0; padding: 20px; background: linear-gradient(135deg, #f5f7fa 0%, #e8f5e9 100%); border-radius: 12px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); }
        .single-image-container { display: none; justify-content: center; padding: 20px; }
        .single-image-container.active { display: flex; }
        .image-item { position: relative; text-align: center; }
        .image-wrapper { position: relative; display: inline-block; margin-bottom: 15px; border-radius: 12px; overflow: hidden; box-shadow: 0 15px 40px rgba(0,0,0,0.3); }
        .board-image-preview { max-width: 500px; width: 100%; border-radius: 12px; display: block; background: white; border: 3px solid #66bb6a; }
        .image-canvas { position: absolute; top: 0; left: 0; cursor: crosshair; border-radius: 12px; }
        .image-controls { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
        .image-carousel { display: flex; gap: 20px; justify-content: center; align-items: center; margin-bottom: 20px; }

        .drawing-controls-section { display: none; padding: 20px; background: linear-gradient(135deg, #f0f9ff 0%, #e8f5e9 100%); border-radius: 12px; margin-top: 20px; border: 1px solid #b3e5fc; }
        .drawing-controls-section.active { display: block; }
        .slider-group { display: flex; flex-direction: column; align-items: center; gap: 5px; margin-bottom: 15px; }
        .slider-label { font-weight: 600; color: #333; font-size: 0.9em; }
        input[type="range"] { -webkit-appearance: none; width: 80%; max-width: 250px; height: 8px; background: #d3d3d3; border-radius: 5px; outline: none; opacity: 0.7; transition: opacity .2s; }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #2e7d32; cursor: pointer; border-radius: 50%; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #2e7d32; cursor: pointer; border-radius: 50%; }

        .color-picker-section { display: none; text-align: center; margin: 20px 0; padding: 15px; background: linear-gradient(135deg, #fff9e6 0%, #ffe8cc 100%); border-radius: 12px; border: 2px solid #ffc107; }
        .color-picker-section.active { display: block; }
        .color-picker-label { font-weight: bold; color: #333; margin-right: 10px; }
        .color-input { width: 50px; height: 50px; border: 2px solid #2e7d32; border-radius: 8px; cursor: pointer; vertical-align: middle; margin: 0 10px; }

        .button-group, .nav-btn, .undo-btn, .download-btn, .recognize-btn, .add-more-btn, .cancel-btn, .draw-btn, .square-marker-btn, .toggle-marker-btn { /* common styles exist */ }
        .nav-btn { width: 45px; height: 45px; border-radius: 50%; font-size: 1.2em; display:flex; justify-content:center; align-items:center; }
        .nav-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .draw-btn, .square-marker-btn, .undo-btn, .add-more-btn { padding: 10px 15px; font-size: 0.9em; }
        .recognize-btn { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .cancel-btn { background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%); }
        .download-btn { background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%); }
        .undo-btn { background: linear-gradient(135deg, #ff9800 0%, #ffc107 100%); }
        .square-marker-btn { background: linear-gradient(135deg, #9c27b0 0%, #e91e63 100%); }
        
        .floating-toolbar { position: fixed; bottom: 30px; right: 30px; background: linear-gradient(135deg, #2e7d32 0%, #66bb6a 100%); border-radius: 50%; width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 8px 25px rgba(46, 125, 50, 0.6); z-index: 1000; font-size: 28px; transition: all 0.3s ease; border: 3px solid white; }
        .floating-toolbar:hover { transform: scale(1.15); }
        .floating-toolbar.active { background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%); }
        .lock-indicator { position: fixed; top: 30px; right: 30px; background: white; border-radius: 12px; padding: 15px 25px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); z-index: 999; font-weight: bold; font-size: 1.1em; display: none; animation: slideInRight 0.3s ease; }
        .lock-indicator.active { display: block; }
        .lock-indicator.locked { background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%); color: white; }
        .lock-indicator.unlocked { background: linear-gradient(135deg, #2e7d32 0%, #66bb6a 100%); color: white; }
        @keyframes slideInRight { from { opacity: 0; transform: translateX(50px); } to { opacity: 1; transform: translateX(0); } }

        @media (max-width: 768px) {
            .card { padding: 20px; }
            h1 { font-size: 2.2em; }
            .info-section { flex-direction: column; }
            button { padding: 12px 20px; font-size: 1em; }
        }
    </style>
</head>
<body>
    <div class="lock-indicator" id="lockIndicator"><span id="lockStatus"></span></div>
    <div class="floating-toolbar" id="floatingToolbar" onclick="toggleMovementLock()"><span id="toolbarIcon">üîì</span></div>

    <div class="container">
        <div class="card">
            <h1>‚ôü C·ªú VUA ‚ôü</h1>
            <div class="info-section">
                <div class="player-info" id="playerInfoDisplay"><p id="currentPlayer"></p></div>
                <div class="selected-info"><p id="selectedInfo"></p></div>
            </div>

            <div class="import-section">
                <button onclick="document.getElementById('imageInput').click()" class="import-btn">üì∏ D√°n ·∫¢nh Th·∫ø C·ªù</button>
                <input type="file" id="imageInput" accept="image/*" multiple style="display: none;" onchange="handleImageUploadAdd(event)">
                
                <div class="image-carousel" id="imageCarousel" style="display: none;">
                    <button class="nav-btn" id="prevBtn" onclick="prevImage()">‚ùÆ</button>
                    <div id="currentImageNum">1 / 1</div>
                    <button class="nav-btn" id="nextBtn" onclick="nextImage()">‚ùØ</button>
                </div>

                <div class="single-image-container" id="singleImageContainer"></div>
                
                <div class="drawing-controls-section" id="imageDrawingTools">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="slider-group">
                            <label for="arrowSizeSlider" class="slider-label">üéöÔ∏è ƒê·ªô l·ªõn m≈©i t√™n</label>
                            <input type="range" id="arrowSizeSlider" min="0.5" max="2" step="0.1" value="1" oninput="updateArrowSize()">
                        </div>
                        <div class="slider-group">
                            <label for="numberSizeSlider" class="slider-label">üî§ ƒê·ªô l·ªõn s·ªë</label>
                            <input type="range" id="numberSizeSlider" min="0.5" max="2" step="0.1" value="1" oninput="updateNumberSize()">
                        </div>
                    </div>
                    <div class="color-picker-section mt-4" id="colorPickerSection">
                        <label class="color-picker-label">üé® Ch·ªçn M√†u ƒê√°nh D·∫•u √î:</label>
                        <input type="color" id="imageMarkerColor" class="color-input" value="#c20ee9" onchange="updateImageMarkerColor()">
                        <button onclick="toggleImageMarkerMode()" class="square-marker-btn">üñçÔ∏è ƒê√°nh D·∫•u √î</button>
                        <button onclick="clearImageMarkers()" class="square-marker-btn" style="background-color: #e57373;">üóëÔ∏è Xo√°</button>
                    </div>
                </div>

                <div class="button-group" id="imageControlsGroup" style="display: none; margin-top: 15px;">
                    <button onclick="downloadDrawnImage()" class="download-btn">üíæ T·∫£i ·∫¢nh</button>
                    <button onclick="recognizeBoardsFromImages()" class="recognize-btn">ü§ñ Nh·∫≠n Di·ªán</button>
                    <button onclick="addMoreImages()" class="add-more-btn">‚ûï Th√™m ·∫¢nh</button>
                    <button onclick="cancelImageUpload()" class="cancel-btn">‚úï H·ªßy</button>
                </div>
            </div>

            <div class="controls mb-5"><button onclick="toggleBoardMarkerPicker()" class="toggle-marker-btn">üéØ ƒê√°nh D·∫•u B√†n C·ªù</button></div>
            <div class="color-picker-section" id="boardMarkerSection">
                 <label class="color-picker-label">üé® M√†u ƒê√°nh D·∫•u:</label>
                 <input type="color" id="boardMarkerColor" class="color-input" value="#c20ee9" onchange="updateBoardMarkerColor()">
                 <button onclick="toggleBoardMarkerMode()" class="square-marker-btn">üñçÔ∏è ƒê√°nh D·∫•u √î</button>
                 <button onclick="clearBoardMarkers()" class="square-marker-btn" style="background-color: #e57373;">üóëÔ∏è Xo√°</button>
            </div>
            
            <div class="chessboard" id="chessboard"></div>
            
            <div class="controls">
                <button onclick="resetGame()">üîÑ Ch∆°i L·∫°i</button>
                <button onclick="undoMove()">‚¨Ö Ho√†n T√°c</button>
            </div>
        </div>
    </div>

    <script>
        const pieces = { 'P': '‚ôô', 'N': '‚ôò', 'B': '‚ôó', 'R': '‚ôñ', 'Q': '‚ôï', 'K': '‚ôî', 'p': '‚ôü', 'n': '‚ôû', 'b': '‚ôù', 'r': '‚ôú', 'q': '‚ôõ', 'k': '‚ôö' };
        let board = [];
        let selectedSquare = null, validMoves = [], currentPlayer = 'white', moveHistory = [];
        let isBoardMarkerMode = false, boardMarkerColor = '#c20ee9';
        let isImageMarkerMode = false, imageMarkerColor = '#c20ee9';
        let isMovementLocked = false;
        
        const arrowColors = ['#2ecc71', '#e74c3c', '#3498db', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#d35400', '#27ae60', '#c0392b', '#2980b9', '#f39c12', '#8e44ad'];
        let imagesData = [], currentDisplayImageId = 0, isDrawingForImage = false;
        let drawStartX = null, drawStartY = null, firstTapPoint = null;
        let arrowSizeMultiplier = 1, numberSizeMultiplier = 1;
        const isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- Core Chess Logic ---
        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    if (selectedSquare?.row === row && selectedSquare?.col === col) square.classList.add('selected');
                    if (validMoves.some(m => m.row === row && m.col === col)) square.classList.add('valid-move');
                    if (board[row]?.[col]) square.textContent = pieces[board[row][col]];
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (isMovementLocked) return updateInfo('üîí Di chuy·ªÉn ƒëang b·ªã kh√≥a!');
            if (isBoardMarkerMode) {
                const square = document.getElementById('chessboard').children[row * 8 + col];
                square.classList.toggle('marked');
                square.style.setProperty('--mark-color', `${boardMarkerColor}60`);
                return updateInfo(`‚úÖ ƒê√£ ƒë√°nh d·∫•u √¥ v·ªõi m√†u: ${boardMarkerColor}`);
            }
            const piece = board[row]?.[col];
            if (validMoves.some(m => m.row === row && m.col === col)) {
                movePiece(selectedSquare.row, selectedSquare.col, row, col);
                selectedSquare = null; validMoves = [];
            } else if (piece && (currentPlayer === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase())) {
                selectedSquare = { row, col };
                validMoves = calculateValidMoves(row, col, piece);
                updateInfo(`Qu√¢n ${pieces[piece]} ƒë∆∞·ª£c ch·ªçn`);
            }
            renderBoard();
        }

        function calculateValidMoves(row, col, piece) { /* [omitted for brevity, same as before] */ return []; } // This function is large and unchanged, so it's collapsed for readability. The full logic is in the previous response.
        function addDiagonalMoves(row, col, moves, isWhite) { /* [omitted for brevity] */ }
        function addLinearMoves(row, col, moves, isWhite) { /* [omitted for brevity] */ }
        function isValidSquare(row, col) { return row >= 0 && row < 8 && col >= 0 && col < 8; }
        function isOpponentPiece(piece, isWhite) { if (!piece) return false; return isWhite !== (piece === piece.toUpperCase()); }
        
        // --- Full Chess Logic (un-collapsed) ---
        function calculateValidMoves(row, col, piece) {
            const moves = [];
            const pieceLower = piece.toLowerCase();
            const isWhite = piece === piece.toUpperCase();

            if (pieceLower === 'p') {
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                if (board[row + direction]?.[col] === null) moves.push({ row: row + direction, col });
                if (row === startRow && board[row + direction][col] === null && board[row + 2 * direction]?.[col] === null) moves.push({ row: row + 2 * direction, col });
                if (board[row + direction]?.[col - 1] && isOpponentPiece(board[row + direction][col - 1], isWhite)) moves.push({ row: row + direction, col: col - 1 });
                if (board[row + direction]?.[col + 1] && isOpponentPiece(board[row + direction][col + 1], isWhite)) moves.push({ row: row + direction, col: col + 1 });
            } else if (pieceLower === 'n') {
                [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => {
                    const newRow = row + dr, newCol = col + dc;
                    if (isValidSquare(newRow, newCol) && (!board[newRow][newCol] || isOpponentPiece(board[newRow][newCol], isWhite))) moves.push({ row: newRow, col: newCol });
                });
            } else if (pieceLower === 'b') addDiagonalMoves(row, col, moves, isWhite);
            else if (pieceLower === 'r') addLinearMoves(row, col, moves, isWhite);
            else if (pieceLower === 'q') { addDiagonalMoves(row, col, moves, isWhite); addLinearMoves(row, col, moves, isWhite); }
            else if (pieceLower === 'k') {
                for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const newRow = row + dr, newCol = col + dc;
                    if (isValidSquare(newRow, newCol) && (!board[newRow][newCol] || isOpponentPiece(board[newRow][newCol], isWhite))) moves.push({ row: newRow, col: newCol });
                }
            }
            return moves;
        }

        function addDirectionalMoves(row, col, moves, isWhite, directions) {
            directions.forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + i * dr, newCol = col + i * dc;
                    if (!isValidSquare(newRow, newCol)) break;
                    if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol });
                    } else if (isOpponentPiece(board[newRow][newCol], isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                        break;
                    } else break;
                }
            });
        }
        function addDiagonalMoves(row, col, moves, isWhite) { addDirectionalMoves(row, col, moves, isWhite, [[-1, -1], [-1, 1], [1, -1], [1, 1]]); }
        function addLinearMoves(row, col, moves, isWhite) { addDirectionalMoves(row, col, moves, isWhite, [[-1, 0], [1, 0], [0, -1], [0, 1]]); }
        
        function movePiece(fromRow, fromCol, toRow, toCol) {
            moveHistory.push({ from: [fromRow, fromCol], to: [toRow, toCol], piece: board[fromRow][fromCol], captured: board[toRow][toCol] });
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updatePlayerInfo();
        }

        function undoMove() {
            if (!moveHistory.length) return updateInfo('Kh√¥ng c√≥ n∆∞·ªõc ƒëi ƒë·ªÉ ho√†n t√°c!');
            const lastMove = moveHistory.pop();
            board[lastMove.from[0]][lastMove.from[1]] = lastMove.piece;
            board[lastMove.to[0]][lastMove.to[1]] = lastMove.captured;
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            selectedSquare = null; validMoves = [];
            renderBoard(); updatePlayerInfo();
        }

        function resetGame() {
            board = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'], ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            selectedSquare = null; validMoves = []; currentPlayer = 'white'; moveHistory = [];
            renderBoard(); updatePlayerInfo();
        }

        // --- UI & Controls Logic ---
        function updatePlayerInfo() { document.getElementById('currentPlayer').innerHTML = `L∆∞·ª£t ch∆°i: <span class="font-bold">${currentPlayer === 'white' ? 'Tr·∫Øng' : 'ƒêen'}</span>`; }
        function updateInfo(message) { document.getElementById('selectedInfo').textContent = message; }
        function toggleBoardMarkerPicker() { document.getElementById('boardMarkerSection').classList.toggle('active'); }
        function updateBoardMarkerColor() { boardMarkerColor = document.getElementById('boardMarkerColor').value; }
        function toggleBoardMarkerMode() { isBoardMarkerMode = !isBoardMarkerMode; updateInfo(isBoardMarkerMode ? 'üñçÔ∏è Ch·∫ø ƒë·ªô ƒë√°nh d·∫•u b√†n c·ªù B·∫¨T' : 'Tho√°t ch·∫ø ƒë·ªô ƒë√°nh d·∫•u'); }
        function clearBoardMarkers() {
            document.querySelectorAll('.square.marked').forEach(s => { s.classList.remove('marked'); s.style.setProperty('--mark-color', ''); });
            updateInfo('üóëÔ∏è ƒê√£ xo√° t·∫•t c·∫£ ƒë√°nh d·∫•u b√†n c·ªù');
        }

        // --- Image & Drawing Logic ---
        function handleImageUploadAdd(event) {
            Array.from(event.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = e => {
                    imagesData.push({ src: e.target.result, arrows: [], markers: [] });
                    showCarouselView();
                };
                reader.readAsDataURL(file);
            });
            event.target.value = ''; // Allow re-uploading the same file
        }

        function addMoreImages() { document.getElementById('imageInput').click(); }

        function showCarouselView() {
            document.getElementById('imageDrawingTools').classList.add('active');
            document.getElementById('imageControlsGroup').style.display = 'flex';
            document.getElementById('imageCarousel').style.display = imagesData.length > 1 ? 'flex' : 'none';
            document.getElementById('singleImageContainer').classList.add('active');
            updateCarouselDisplay();
        }

        function updateCarouselDisplay() {
            const container = document.getElementById('singleImageContainer');
            container.innerHTML = '';
            if (imagesData.length === 0) return;

            const imageData = imagesData[currentDisplayImageId];
            container.innerHTML = `
                <div class="image-item">
                    <div class="image-wrapper">
                        <img src="${imageData.src}" class="board-image-preview" id="carousel-img">
                        <canvas id="carousel-canvas" class="image-canvas"></canvas>
                    </div>
                    <div class="image-controls">
                        <button onclick="toggleDrawingModeCarousel()" class="draw-btn">‚úèÔ∏è V·∫Ω M≈©i T√™n</button>
                        <button onclick="undoDrawingCarousel()" class="undo-btn">‚Ü∂ Ho√†n T√°c V·∫Ω</button>
                    </div>
                </div>`;
            
            const img = document.getElementById('carousel-img');
            img.onload = () => {
                const canvas = document.getElementById('carousel-canvas');
                canvas.width = img.offsetWidth;
                canvas.height = img.offsetHeight;
                redrawCanvasCarousel();
            };
            if (img.complete) img.onload();
            
            document.getElementById('currentImageNum').textContent = `${currentDisplayImageId + 1} / ${imagesData.length}`;
            document.getElementById('prevBtn').disabled = currentDisplayImageId === 0;
            document.getElementById('nextBtn').disabled = currentDisplayImageId === imagesData.length - 1;
        }

        function prevImage() { if (currentDisplayImageId > 0) { currentDisplayImageId--; updateCarouselDisplay(); } }
        function nextImage() { if (currentDisplayImageId < imagesData.length - 1) { currentDisplayImageId++; updateCarouselDisplay(); } }

        function toggleDrawingModeCarousel() {
            isDrawingForImage = !isDrawingForImage;
            const canvas = document.getElementById('carousel-canvas');
            if (isDrawingForImage) {
                if (isMobile) {
                    canvas.onclick = handleCanvasTap;
                    updateInfo(`üì± Ch·∫°m v√†o 2 ƒëi·ªÉm ƒë·ªÉ v·∫Ω m≈©i t√™n.`);
                } else {
                    canvas.onmousedown = startDrawingCarousel; canvas.onmousemove = drawArrowCarousel;
                    canvas.onmouseup = endDrawingCarousel; canvas.onmouseout = endDrawingCarousel;
                    updateInfo(`üñåÔ∏è K√©o th·∫£ ƒë·ªÉ v·∫Ω m≈©i t√™n.`);
                }
            } else {
                canvas.onclick = canvas.onmousedown = canvas.onmousemove = canvas.onmouseup = canvas.onmouseout = null;
                updateInfo('Tho√°t ch·∫ø ƒë·ªô v·∫Ω.');
                firstTapPoint = null;
            }
        }
        
        function handleImageMarkerClick(x, y) {
            const img = document.getElementById('carousel-img');
            const [col, row] = [Math.floor(x / (img.offsetWidth / 8)), Math.floor(y / (img.offsetHeight / 8))];
            if (isValidSquare(row, col)) {
                const markerId = `${row}-${col}`;
                const markers = imagesData[currentDisplayImageId].markers;
                const index = markers.indexOf(markerId);
                if (index > -1) markers.splice(index, 1);
                else markers.push(markerId);
                redrawCanvasCarousel();
                updateInfo(`‚úÖ ƒê√£ ƒë√°nh d·∫•u √¥ (${row}, ${col})`);
            }
        }
        
        function handleCanvasTap(e) {
            const { x, y } = getCanvasCoords(e);
            if (isImageMarkerMode) return handleImageMarkerClick(x, y);
            
            if (!firstTapPoint) {
                firstTapPoint = { x, y };
                updateInfo(`‚úÖ ƒêi·ªÉm 1: (${x}, ${y}). Ch·∫°m ƒëi·ªÉm th·ª© 2.`);
            } else {
                const arrows = imagesData[currentDisplayImageId].arrows;
                arrows.push({ startX: firstTapPoint.x, startY: firstTapPoint.y, endX: x, endY: y, color: arrowColors[arrows.length % arrowColors.length] });
                redrawCanvasCarousel();
                updateInfo(`‚úÖ ƒê√£ v·∫Ω m≈©i t√™n! T·ªïng s·ªë: ${arrows.length}`);
                firstTapPoint = null;
            }
        }
        
        function startDrawingCarousel(e) {
            const { x, y } = getCanvasCoords(e);
            if (isImageMarkerMode) return handleImageMarkerClick(x, y);
            drawStartX = x; drawStartY = y;
        }

        function drawArrowCarousel(e) {
            if (isImageMarkerMode || drawStartX === null) return;
            const { x, y } = getCanvasCoords(e);
            redrawCanvasCarousel();
            const arrows = imagesData[currentDisplayImageId].arrows;
            drawArrowOnCanvas(getCanvasContext(), drawStartX, drawStartY, x, y, arrowColors[arrows.length % arrowColors.length], arrows.length);
        }

        function endDrawingCarousel(e) {
            if (isImageMarkerMode || drawStartX === null) return;
            const { x, y } = getCanvasCoords(e);
            if (Math.hypot(x - drawStartX, y - drawStartY) > 10) {
                 const arrows = imagesData[currentDisplayImageId].arrows;
                 arrows.push({ startX: drawStartX, startY: drawStartY, endX: x, endY: y, color: arrowColors[arrows.length % arrowColors.length] });
                 updateInfo(`‚úÖ ƒê√£ v·∫Ω m≈©i t√™n! T·ªïng s·ªë: ${arrows.length}`);
            }
            drawStartX = null; drawStartY = null;
            redrawCanvasCarousel();
        }
        
        function getCanvasCoords(e) {
            const rect = document.getElementById('carousel-canvas').getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: Math.round(clientX - rect.left), y: Math.round(clientY - rect.top) };
        }
        
        function getCanvasContext() { return document.getElementById('carousel-canvas')?.getContext('2d'); }

        function redrawCanvasCarousel() {
            const ctx = getCanvasContext();
            if (!ctx) return;
            const canvas = ctx.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const img = document.getElementById('carousel-img');
            const [sqWidth, sqHeight] = [img.offsetWidth / 8, img.offsetHeight / 8];
            
            imagesData[currentDisplayImageId].markers.forEach(markerId => {
                const [row, col] = markerId.split('-').map(Number);
                ctx.fillStyle = imageMarkerColor + '60';
                ctx.fillRect(col * sqWidth, row * sqHeight, sqWidth, sqHeight);
            });
            
            imagesData[currentDisplayImageId].arrows.forEach((arrow, index) => {
                drawArrowOnCanvas(ctx, arrow.startX, arrow.startY, arrow.endX, arrow.endY, arrow.color, index);
            });
        }
        
        function drawArrowOnCanvas(ctx, fromX, fromY, toX, toY, color, index) {
            const baseSize = 5;
            const headlen = 4 * baseSize * arrowSizeMultiplier;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            // Arrow line
            ctx.strokeStyle = color;
            ctx.lineWidth = baseSize * arrowSizeMultiplier;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            // Arrow head
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();

            // Number circle
            const fontSize = 12 * numberSizeMultiplier;
            const circleRadius = fontSize * 0.9;
            ctx.beginPath();
            ctx.arc(fromX, fromY, circleRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1 * numberSizeMultiplier;
            ctx.stroke();

            // Number text
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(index + 1, fromX, fromY);
        }

        function undoDrawingCarousel() {
            const arrows = imagesData[currentDisplayImageId]?.arrows;
            if (arrows?.length > 0) {
                arrows.pop();
                redrawCanvasCarousel();
                updateInfo(`‚Ü∂ Ho√†n t√°c. C√≤n l·∫°i: ${arrows.length} m≈©i t√™n.`);
            } else updateInfo('Kh√¥ng c√≥ g√¨ ƒë·ªÉ ho√†n t√°c!');
        }
        
        function downloadDrawnImage() {
            const img = document.getElementById('carousel-img');
            const canvas = document.getElementById('carousel-canvas');
            if (!img) return updateInfo('‚ö†Ô∏è Vui l√≤ng t·∫£i ·∫£nh tr∆∞·ªõc!');
            
            const dlCanvas = document.createElement('canvas');
            dlCanvas.width = img.naturalWidth;
            dlCanvas.height = img.naturalHeight;
            const ctx = dlCanvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0);
            if (canvas) {
                const scaleX = img.naturalWidth / canvas.width;
                const scaleY = img.naturalHeight / canvas.height;
                ctx.save();
                ctx.scale(scaleX, scaleY);
                ctx.drawImage(canvas, 0, 0);
                ctx.restore();
            }

            const link = document.createElement('a');
            link.href = dlCanvas.toDataURL('image/png');
            link.download = `chess-analysis-${currentDisplayImageId + 1}.png`;
            link.click();
            updateInfo('‚úÖ T·∫£i ·∫£nh th√†nh c√¥ng!');
        }

        function recognizeBoardsFromImages() { alert("ü§ñ T√≠nh nƒÉng nh·∫≠n di·ªán th·∫ø c·ªù t·ª´ ·∫£nh ƒëang trong giai ƒëo·∫°n ph√°t tri·ªÉn v√† s·∫Ω s·ªõm ƒë∆∞·ª£c ho√†n thi·ªán. C·∫£m ∆°n b·∫°n ƒë√£ ki√™n nh·∫´n!"); }

        function cancelImageUpload() {
            imagesData = []; currentDisplayImageId = 0;
            document.getElementById('singleImageContainer').classList.remove('active');
            document.getElementById('imageCarousel').style.display = 'none';
            document.getElementById('imageControlsGroup').style.display = 'none';
            document.getElementById('imageDrawingTools').classList.remove('active');
            updateInfo('Ch·ªçn qu√¢n c·ªù ƒë·ªÉ di chuy·ªÉn');
        }

        function updateArrowSize() { arrowSizeMultiplier = document.getElementById('arrowSizeSlider').value; redrawCanvasCarousel(); }
        function updateNumberSize() { numberSizeMultiplier = document.getElementById('numberSizeSlider').value; redrawCanvasCarousel(); }
        function updateImageMarkerColor() { imageMarkerColor = document.getElementById('imageMarkerColor').value; redrawCanvasCarousel(); }
        function toggleImageMarkerMode() {
             isImageMarkerMode = !isImageMarkerMode;
             document.getElementById('colorPickerSection').classList.toggle('active', isImageMarkerMode);
             updateInfo(isImageMarkerMode ? 'üñçÔ∏è Ch·∫ø ƒë·ªô ƒë√°nh d·∫•u √î B·∫¨T' : 'Tho√°t ch·∫ø ƒë·ªô ƒë√°nh d·∫•u √¥.');
        }
        function clearImageMarkers() {
            if (imagesData[currentDisplayImageId]) {
                imagesData[currentDisplayImageId].markers = [];
                redrawCanvasCarousel();
                updateInfo('üóëÔ∏è ƒê√£ xo√° ƒë√°nh d·∫•u tr√™n ·∫£nh.');
            }
        }
        
        function toggleMovementLock() {
            isMovementLocked = !isMovementLocked;
            const status = isMovementLocked ? 'locked' : 'unlocked';
            const text = isMovementLocked ? 'üîí Kh√≥a di chuy·ªÉn' : 'üîì M·ªü kh√≥a';
            document.getElementById('floatingToolbar').classList.toggle('active', isMovementLocked);
            document.getElementById('toolbarIcon').textContent = isMovementLocked ? 'üîí' : 'üîì';
            const indicator = document.getElementById('lockIndicator');
            indicator.className = `lock-indicator active ${status}`;
            indicator.firstElementChild.textContent = text;
            setTimeout(() => indicator.classList.remove('active'), 2000);
            updateInfo(isMovementLocked ? 'üîí Di chuy·ªÉn ƒë√£ b·ªã kh√≥a.' : 'üîì Di chuy·ªÉn ƒë∆∞·ª£c m·ªü kh√≥a.');
        }

        window.onload = () => {
            resetGame();
        };
    </script>
</body>
</html>
